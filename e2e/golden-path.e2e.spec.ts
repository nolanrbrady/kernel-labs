import { spawn, type ChildProcessWithoutNullStreams } from "node:child_process"
import { once } from "node:events"
import { createServer } from "node:net"

import { expect, request as playwrightRequest, test, type Page } from "@playwright/test"

type RuntimeSuccessPayload = {
  status: "success"
  problemId: string
  output: number[][]
}

type EvaluatorPayload = {
  correctness: "pass" | "partial" | "fail"
  explanation: string
}

type SchedulerDecisionPayload = {
  nextIntervalDays: number
  resurfacingPriority: number
}

type SchedulerPlanPayload = {
  assignedProblemIds: string[]
  resurfacedAssignedCount: number
}

type SubmissionPayload = {
  submissionAccepted: boolean
  nextState: {
    status: "active" | "done"
  }
}

let appProcess: ChildProcessWithoutNullStreams
let baseUrl: string

const ATTENTION_REFERENCE_SOLUTION = `
def scaled_dot_product_attention(q, k, v, mask=None):
    import numpy as np
    scores = (q @ k.T) / np.sqrt(k.shape[-1])
    if mask is not None:
        scores = scores + mask
    scores = scores - np.max(scores, axis=-1, keepdims=True)
    weights = np.exp(scores)
    weights = weights / np.sum(weights, axis=-1, keepdims=True)
    return weights @ v
`

async function allocateFreePort(): Promise<number> {
  return await new Promise((resolve, reject) => {
    const server = createServer()

    server.on("error", reject)
    server.listen(0, () => {
      const address = server.address()

      if (address === null || typeof address === "string") {
        reject(new Error("Unable to allocate a free port for E2E tests."))
        return
      }

      const { port } = address
      server.close((error) => {
        if (error) {
          reject(error)
          return
        }

        resolve(port)
      })
    })
  })
}

async function waitForServerReady(url: string): Promise<void> {
  const deadline = Date.now() + 10_000

  while (Date.now() < deadline) {
    try {
      const response = await fetch(`${url}/health`)

      if (response.ok) {
        return
      }
    } catch {
      // no-op: retry until timeout
    }

    await new Promise((resolve) => {
      setTimeout(resolve, 100)
    })
  }

  throw new Error(`Server did not become ready at ${url} within timeout.`)
}

async function runReferenceSolution(page: Page): Promise<void> {
  await page.locator("#starter-code-editor").fill(ATTENTION_REFERENCE_SOLUTION.trim())
  await page.locator("#run-button").click()
  await expect(page.locator("#run-status")).toHaveText(
    "Run complete. Output generated by your submitted code on deterministic toy tensors."
  )
  await expect(page.locator("#evaluation-status")).toHaveText(/^Evaluation: pass -/)
}

test.beforeAll(async () => {
  const port = await allocateFreePort()
  baseUrl = `http://127.0.0.1:${port}`
  appProcess = spawn(
    process.execPath,
    ["--import", "tsx", "src/backend/start.ts"],
    {
      cwd: process.cwd(),
      env: {
        ...process.env,
        PORT: String(port)
      },
      stdio: "pipe"
    }
  )

  await waitForServerReady(baseUrl)
})

test.afterAll(async () => {
  if (!appProcess.killed && appProcess.exitCode === null) {
    appProcess.kill("SIGTERM")
    await once(appProcess, "exit")
  }
})

test("golden path covers landing, run, submit, schedule update, and session end", async () => {
  const apiContext = await playwrightRequest.newContext({
    baseURL: baseUrl
  })

  try {
    const landingResponse = await apiContext.get("/")
    const landingHtml = await landingResponse.text()

    expect(landingResponse.ok()).toBeTruthy()
    expect(landingHtml.includes("problem-workspace")).toBeTruthy()

    const problemId = "attention_scaled_dot_product_v1"
    const runResponse = await apiContext.post("/api/runtime/run", {
      data: {
        problemId,
        userCode: `def scaled_dot_product_attention(q, k, v, mask=None):
    scores = q @ k.transpose(-1, -2)
    return scores`
      }
    })
    const runPayload = (await runResponse.json()) as RuntimeSuccessPayload

    expect(runResponse.ok()).toBeTruthy()
    expect(runPayload.status).toBe("success")

    const evaluatorResponse = await apiContext.post("/api/evaluator/evaluate", {
      data: {
        problemId,
        candidateOutput: runPayload.output
      }
    })
    const evaluatorPayload = (await evaluatorResponse.json()) as EvaluatorPayload

    expect(evaluatorResponse.ok()).toBeTruthy()
    expect(["pass", "partial", "fail"].includes(evaluatorPayload.correctness)).toBeTruthy()

    const schedulerDecisionResponse = await apiContext.post(
      "/api/scheduler/decision",
      {
        data: {
          correctness: evaluatorPayload.correctness,
          timeSpentMinutes: 16,
          hintTierUsed: 1,
          priorSuccessfulCompletions: 0,
          daysSinceLastExposure: 2
        }
      }
    )
    const schedulerDecisionPayload =
      (await schedulerDecisionResponse.json()) as SchedulerDecisionPayload

    expect(schedulerDecisionResponse.ok()).toBeTruthy()
    expect(schedulerDecisionPayload.nextIntervalDays).toBeGreaterThanOrEqual(1)
    expect(schedulerDecisionPayload.resurfacingPriority).toBeGreaterThanOrEqual(0)

    const schedulerPlanResponse = await apiContext.post("/api/scheduler/plan", {
      data: {
        newProblemIds: [],
        resurfacedCandidates: [
          {
            problemId,
            resurfacingPriority: schedulerDecisionPayload.resurfacingPriority
          },
          {
            problemId: "rnn_hidden_state_update_v1",
            resurfacingPriority: 0.42
          }
        ]
      }
    })
    const schedulerPlanPayload =
      (await schedulerPlanResponse.json()) as SchedulerPlanPayload

    expect(schedulerPlanResponse.ok()).toBeTruthy()
    expect(schedulerPlanPayload.assignedProblemIds.length).toBe(1)
    expect(schedulerPlanPayload.resurfacedAssignedCount).toBeLessThanOrEqual(1)

    const submitResponse = await apiContext.post("/api/session/submit", {
      data: {
        sessionId: "golden-path-session-001",
        problemId,
        correctness: evaluatorPayload.correctness,
        explanation: evaluatorPayload.explanation,
        submittedAt: "2026-02-16T18:25:00Z"
      }
    })
    const submitPayload = (await submitResponse.json()) as SubmissionPayload

    expect(submitResponse.ok()).toBeTruthy()
    expect(submitPayload.submissionAccepted).toBeTruthy()
    expect(submitPayload.nextState.status).toBe("done")
  } finally {
    await apiContext.dispose()
  }
})

test("workspace UI buttons remain clickable when suggest-topic modal is hidden", async ({
  page
}) => {
  await page.goto(`${baseUrl}/`)

  await expect(page.locator("#suggest-topic-modal")).toBeHidden()
  await expect(page.locator("#session-timer-status")).toHaveText(
    "Session timer: not started (30:00 limit)."
  )

  await page.locator("#start-problem-button").click()
  await expect(page.locator("#session-timer-status")).toHaveText(
    "Session timer: 30:00 remaining."
  )

  await page.locator("#workspace-tab-library").click()
  await expect(page.locator("#workspace-library-tab-panel")).toBeVisible()
  await expect(page.locator("#workspace-problem-tab-panel")).toBeHidden()

  await page.locator("#workspace-tab-problem").click()
  await expect(page.locator("#workspace-problem-tab-panel")).toBeVisible()
  await expect(page.locator("#workspace-library-tab-panel")).toBeHidden()
})

test("clicking visible code surface focuses editor and allows typing", async ({
  page
}) => {
  await page.goto(`${baseUrl}/`)

  await expect(page.locator("#session-timer-status")).toHaveText(
    "Session timer: not started (30:00 limit)."
  )

  await page.locator(".code-editor-shell").click({ position: { x: 24, y: 24 } })
  await expect
    .poll(async () => {
      return await page.evaluate(() => {
        return document.activeElement && document.activeElement.id;
      });
    })
    .toBe("starter-code-editor")
  await expect(page.locator(".code-editor-shell")).toHaveClass(/is-editing/)
  await expect
    .poll(async () => {
      return await page.evaluate(() => {
        const highlight = document.getElementById("starter-code-highlight");
        if (!highlight) {
          return "missing";
        }
        return window.getComputedStyle(highlight).opacity;
      });
    })
    .toBe("1")

  await page.keyboard.type("a")
  await expect(page.locator("#session-timer-status")).toHaveText(
    "Session timer: 30:00 remaining."
  )
})

test("run flow updates evaluator and visible test case statuses from fail to pass", async ({
  page
}) => {
  await page.goto(`${baseUrl}/`)

  await page.locator("#run-button").click()
  await expect(page.locator("#run-status")).toHaveText(
    /Code could not be parsed or loaded:|Run completed, but output is not a 2D numeric tensor\./
  )
  await expect(page.locator("#evaluation-status")).toHaveText(
    "Evaluation skipped until run succeeds."
  )
  await expect(page.locator("#test-case-status-case_1_balanced_tokens")).toHaveText(
    "Run failed"
  )
  await expect(page.locator("#test-case-status-case_2_causal_masking")).toHaveText(
    "Run failed"
  )
  await expect(page.locator("#test-case-status-case_3_stability_magnitudes")).toHaveText(
    "Run failed"
  )

  await runReferenceSolution(page)
  await expect(page.locator("#test-case-status-case_1_balanced_tokens")).toHaveText("Pass")
  await expect(page.locator("#test-case-status-case_2_causal_masking")).toHaveText("Pass")
  await expect(page.locator("#test-case-status-case_3_stability_magnitudes")).toHaveText("Pass")
  await expect(page.locator("#debug-shell-output")).toContainText(
    "> runtime test cases: 3/3 passed."
  )
})

test("manual submit marks session complete and renders scheduler details", async ({
  page
}) => {
  await page.goto(`${baseUrl}/`)

  await page.locator("#start-problem-button").click()
  await expect(page.locator("#session-timer-status")).toHaveText(
    "Session timer: 30:00 remaining."
  )

  await runReferenceSolution(page)
  await page.locator("#submit-button").click()

  await expect(page.locator("#session-status")).toContainText(
    "Session status: done. Submission accepted."
  )
  await expect(page.locator("#session-timer-status")).toHaveText("Session timer: completed.")
  await expect(page.locator("#next-presentation-status")).toHaveText(
    /Days until next presentation: \d+ day\(s\) \(\d{4}-\d{2}-\d{2}\)\./
  )
  await expect(page.locator("#schedule-status")).toHaveText(
    /Scheduling details: resurfacing priority [0-9.]+\./
  )
})

test("hint tiers reveal in sequence and unlock progressively", async ({ page }) => {
  await page.goto(`${baseUrl}/`)

  await expect(page.locator("#hint-tier-2-button")).toBeDisabled()
  await expect(page.locator("#hint-tier-3-button")).toBeDisabled()

  await page.locator("#hint-tier-1-button").click()
  await expect(page.locator("#hint-tier-1-text")).toContainText("Tier 1 (Conceptual):")
  await expect(page.locator("#hint-status")).toHaveText(
    "Hint tier 1 revealed. You can still submit at any time."
  )
  await expect(page.locator("#hint-tier-2-button")).toBeEnabled()

  await page.locator("#hint-tier-2-button").click()
  await expect(page.locator("#hint-tier-2-text")).toContainText("Tier 2 (Structural):")
  await expect(page.locator("#hint-status")).toHaveText(
    "Hint tier 2 revealed. You can still submit at any time."
  )
  await expect(page.locator("#hint-tier-3-button")).toBeEnabled()

  await page.locator("#hint-tier-3-button").click()
  await expect(page.locator("#hint-tier-3-text")).toContainText("Tier 3 (Near-code):")
  await expect(page.locator("#hint-status")).toHaveText(
    "All hint tiers revealed. Submit whenever you are ready."
  )
})

test("question library supports zero-result filtering", async ({ page }) => {
  await page.goto(`${baseUrl}/`)

  await page.locator("#workspace-tab-library").click()
  await page.locator("#question-search-input").fill("playwright-no-match-zzzzz")

  await expect(page.locator("#question-library-count")).toHaveText(
    /Showing 0 of \d+ questions\./
  )
  await expect(page.locator("#question-library-results")).toContainText(
    "No matching questions yet. Try a different keyword or type."
  )
})

test("suggest-topic modal can submit a valid proposal end-to-end", async ({ page }) => {
  await page.goto(`${baseUrl}/`)

  await page.locator("#workspace-tab-library").click()
  await page.locator("#suggest-topic-button").click()

  const suggestTopicModal = page.locator("#suggest-topic-modal")
  await expect(suggestTopicModal).toBeVisible()
  await expect(page.locator("#suggest-topic-status")).toHaveText(
    "Topic suggestion modal opened for all problem types."
  )

  await page.locator("#suggest-topic-title").fill("Masked Softmax Stability Drill")
  await page.locator("#suggest-topic-problem-type").fill("Attention")
  await page.locator("#suggest-topic-difficulty").selectOption("Medium")
  await page
    .locator("#suggest-topic-learning-objective")
    .fill(
      "Implement masked softmax attention behavior correctly so the learner can reason through shape flow, masking semantics, and stable normalization on deterministic toy tensors without relying on hidden training behavior."
    )
  await page
    .locator("#suggest-topic-context")
    .fill(
      "Scaled dot-product attention is easy to mis-implement when masks, axis semantics, and stability constraints are mixed together. This drill isolates those details and forces explicit handling of logits, additive mask bias, and post-softmax value mixing on small deterministic tensors. The goal is to reinforce robust implementation habits that transfer to production transformer code."
    )
  await page
    .locator("#suggest-topic-input-spec")
    .fill(
      "q: [3, 2]; k: [3, 2]; v: [3, 2]; mask: [3, 3] additive bias mask with 0 for allowed positions and -1e9 for blocked positions."
    )
  await page
    .locator("#suggest-topic-output-spec")
    .fill(
      "Output shape [3, 2] with finite values, stable masked softmax semantics, and expected weighting behavior over keys for each query row."
    )
  await page
    .locator("#suggest-topic-constraints")
    .fill(
      "Use deterministic toy tensors only; enforce stable softmax with max subtraction; preserve axis order for q @ k.T and weights @ v; include edge behavior for strict masking and repeated rows."
    )
  await page
    .locator("#suggest-topic-starter-signature")
    .fill("def masked_softmax_attention(q, k, v, mask=None):")
  await page
    .locator("#suggest-topic-visible-tests")
    .fill(
      "Case 1: balanced tokens without mask; Case 2: causal additive mask blocks future tokens; Case 3: high-magnitude logits remain finite and stable."
    )
  await page
    .locator("#suggest-topic-paper-link")
    .fill("https://arxiv.org/abs/1706.03762")

  await page.locator("#suggest-topic-form").locator("button[type='submit']").click()

  await expect(suggestTopicModal).toBeHidden()
  await expect(page.locator("#suggest-topic-status")).toHaveText(
    "Topic suggestion captured for Attention: Masked Softmax Stability Drill."
  )
  await expect(page.locator("#debug-shell-output")).toContainText(
    "> topic suggestion ProblemSpecV2:"
  )
})

test("problem flag flow accepts first flag and deduplicates repeated flag", async ({
  page
}) => {
  await page.goto(`${baseUrl}/`)

  const noteText = `playwright-flag-${Date.now()}`
  await page.locator("#flag-problem-notes").fill(noteText)
  await page.locator("#flag-problem-button").click()

  await expect(page.locator("#flag-problem-status")).toHaveText(
    /Flag submitted\. Verification status: [a-z_]+\./
  )

  await page.locator("#flag-problem-button").click()
  await expect(page.locator("#flag-problem-status")).toHaveText(
    "Duplicate flag noted. Existing review item is already queued."
  )
})

test("session auto-submits at 30-minute cap", async ({ page }) => {
  await page.goto(`${baseUrl}/`)

  await page.locator("#start-problem-button").click()
  await expect(page.locator("#session-timer-status")).toHaveText(
    "Session timer: 30:00 remaining."
  )

  await page.evaluate(() => {
    const originalNow = Date.now.bind(Date)
    Date.now = () => originalNow() + 31 * 60 * 1000
  })

  await expect(page.locator("#timer-cap-message")).toHaveText(
    "30-minute cap reached. Your session was submitted automatically."
  )
  await expect(page.locator("#session-status")).toContainText("Session status: done.")
  await expect(page.locator("#session-timer-status")).toHaveText("Session timer: completed.")
})
